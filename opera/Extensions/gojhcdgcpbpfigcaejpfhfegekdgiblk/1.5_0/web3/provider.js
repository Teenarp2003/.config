"use strict";const METAMASK_SPOOF_HOST_LIST=["adamantmine.com","app.allbridge.io","app.deversifi.com","app.hop.exchange","app.launchpool.xyz","app.xwg.games","beta.blockapescissors.com","boredapeyachtclub.com","bridge.roninchain.com","bridge.umbria.network","coinracer.io","crazydefenseheroes.com","cryptocars.me","cryptoflowers.io","cryptopioneers.co","cryptounicorns.fun","curve.fi","dentedfeelsnft.com","etherlambos.io","foundation.app","game.lordless.io","gardenlockdown.com","guildfi.com","hashelot.onrender.com","hex.com","knownorigin.io","looksrare.org","market.immutable.com","marketplace.thetanarena.com","matcha.xyz","mcp3d.com","metalink.com","nft.gamestop.com","niftychars.com","opensea.io","pegaxy.io","phantomgalaxies.com","play.mydefipet.com","pro.apeswap.finance","qorpo.world","stake.lido.fi","thedustland.com","unstoppabledomains.com","wolf.game","www.binance.com","www.cryptoatoms.org","www.cryptoblades.io","www.kingofeth.com","www.larvalabs.com","www.mintverse.com","www.mobox.io","www.nagemon.com","www.stateofthedapps.com","www.vibehub.io","www.voxels.com"];(function(){function e(e){return"error"in e}function t(e){return"undefined"===typeof e.id}function n(){const e=new m(new u);o(e,location.host),i(e),window.ethereum=e}function s(e,t,n){Object.defineProperty(e,t,{enumerable:!0,value:n})}function i(e){const t="__isMetaMaskShim__";if(window.web3){const e=Object.keys(window.web3),n=1===e.length&&"currentProvider"===e[0],s=e.includes(t),i=n||s;if(!i)return}const n={currentProvider:e};s(n,t,!0),window.web3=n}function o(e,t){if(c(t))return s(e,"isMetaMask",!0),void s(e,"_metamask",{isUnlocked(){return Promise.resolve(!0)}});s(e,"isOpera",!0),s(e,"providerName","opera")}function r(e,t){return!!e.endsWith(t)&&(e.length===t.length||"."===e.at(-(t.length+1)))}function c(e){return!!METAMASK_SPOOF_HOST_LIST.find((t=>r(e,t)))}function a(e,t,n){const s=`Web3Provider.${n}`;if(e.length!==t.length)throw new TypeError(`${s} got ${e.length} arguments`);const i={o:"object",f:"function",s:"string"};for(let o=0;o<t.length;++o){const n=i[t.charAt(o)],r=typeof e[o];if(r!==n)throw new TypeError(`${s} argument ${o} got ${r}, expected ${n}`)}}function h(e,t){e.chainId=t||null,e.networkVersion=t?parseInt(t).toString():null}class d{_events={};emit(e,...t){const n=this._events[e]||[];return n.forEach((e=>e.apply(this,t))),this}on(e,t){const n=this._events[e]||[];return this._events[e]=n.concat(t),this}addListener(e,t){return this.on(e,t)}off(e,t){const n=this._events[e];if(n){const s=n.lastIndexOf(t);if(s>=0){const t=n.filter(((e,t)=>t!==s));t.length?this._events[e]=t:delete this._events[e]}}return this}removeListener(e,t){return this.off(e,t)}removeAllListeners(e){return void 0===e?this._events={}:delete this._events[e],this}}function l(e){return`${(typeof e).charAt(0)}:${e}`}class u extends d{_port;_pending={};_id=0;connect(){const e=new MessageChannel;window.postMessage("InitializeOperaCryptoWalletWeb3Provider","*",[e.port2]);const t=e.port1;t.onmessage=e=>this._handleResponse(e.data),this._port=t}_nextId(){return 4294967295&++this._id}_handleResponse(e){if(t(e))return void this.emit(e.method,e.params);const n=l(e.id);if(!(n in this._pending))return;const s=this._pending[n];delete this._pending[n],s(e)}send(e){e.jsonrpc||(e.jsonrpc="2.0"),e.id=this._nextId();const t=l(e.id);if(t in this._pending)throw new Error(`Malformed request: RPC message with id ${e.id} pending`);return this._port||this.connect(),this._port.postMessage(e),new Promise((e=>this._pending[t]=e))}isConnected(){return!!this._port}}function p(t,n,s){const i=n.map((e=>t.send(Object.assign({},e)).then((t=>(t.id=e.id,t)))));Promise.allSettled(i).then((t=>{const n=t,i=n.map((e=>e.value));s(i.filter((t=>e(t))),i.filter((t=>!e(t))))}))}class m extends d{_rpc;selectedAddress=null;chainId=null;networkVersion=null;constructor(e){super(),this.enable=this.enable.bind(this),this.isConnected=this.isConnected.bind(this),this.send=this.send.bind(this),this.sendAsync=this.sendAsync.bind(this),this.request=this.request.bind(this),this._rpc=e,this._rpc.on("chainChanged",this._handleChainChange.bind(this)).on("accountsChanged",this._handleAccountsChange.bind(this)),this._rpc.connect()}enable(){a(arguments,"","enable()");let t=[];return this._rpc.send({method:"eth_requestAccounts"}).then((t=>e(t)?Promise.reject(t.error):Promise.resolve(t.result))).then((e=>(t=e,Promise.resolve(e)))).finally((()=>this._handleAccountsChange([t])))}isConnected(){return a(arguments,"","isConnected()"),this._rpc.isConnected()}send(e,t){if("string"===typeof e)return this.request({method:e,params:t});let n;switch(a(arguments,"o","send(request)"),e.method){case"eth_accounts":case"eth_requestAccounts":n=this.selectedAddress&&[this.selectedAddress]||[];break;case"eth_coinbase":n=this.selectedAddress||null;break;case"eth_uninstallFilter":this._rpc.send(e),n=!0;break;case"net_version":n=this.networkVersion||null;break;default:throw new Error(`${e.method} not supported by synchronous send()`)}return{id:e.id,jsonrpc:e.jsonrpc,result:n}}sendAsync(e,t){if(a(arguments,"of","sendAsync(request, callback)"),Array.isArray(e)){if(e.length>1)return void p(this._rpc,e,t);[e]=e}this._rpc.send(Object.assign({},e)).then((n=>{n.id=e.id,t(void 0,n)}))}request(t){a(arguments,"o","request(args)");const{method:n,params:s}=t;a([n],"s","request({method: string, ...})");const i={method:n,...s&&{params:s}};return new Promise(((t,n)=>{this._rpc.send(i).then((s=>{e(s)?n(s.error):t(s.result)}))}))}_handleChainChange(e){const[t]=e,{chainId:n}=this;h(this,t),n&&n!==this.chainId&&this.emit("chainChanged",this.chainId)}_handleAccountsChange(e){const[t=[]]=e,[n=null]=t,{selectedAddress:s}=this;this.selectedAddress=n,s&&s!==this.selectedAddress&&this.emit("accountsChanged",this.selectedAddress)}}n()})();